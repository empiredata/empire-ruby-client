require 'yaml'
require 'json'
require 'date'

require 'httpclient'
require 'irb-pager'

require_relative 'walkthrough.rb'

class Empire
  attr_reader :base_url

  # app_key is your Empire application key, and is necessary for using the API
  # opts can include any of:
  #    * :api_server => the server to connect to (default: api.empiredata.com)
  #    * :end_user => a string identifying the end user, required for any operations on views (default: nil)
  #    * :secrets_yaml => the path to a YAML file generated by https://login.empiredata.co (default: nil)
  def initialize(app_key = nil, opts = {})
    api_server = opts[:api_server] || 'api.empiredata.co'

    @app_key = app_key
    @end_user = opts[:end_user]
    @session_key = nil

    @http_client = HTTPClient.new

    protocol = api_server.start_with?('localhost') ? 'http' : 'https'
    @base_url = "#{protocol}://#{api_server}/empire/"

    @service_secrets = nil
    if opts[:secrets_yaml]
      @service_secrets = YAML.load_file opts[:secrets_yaml]
    end
  end

  # Connect to specific service
  # service: service name
  # secrets: hash with service secrets (optional if the Empire instance was initialized with a secrets_yaml)
  def connect(service, secrets = nil)
    path = "services/#{service}/connect"
    unless secrets
      unless @service_secrets
        raise "secrets must be provided on connect command, 
          or secrets_yaml file must be given when constructing this instance"
      end

      secrets = {}
      @service_secrets[service]['option'].each{|k, v| secrets[k] = v['value']}
    end
    request path, :post, {}, secrets
  end

  # Describe all services, all tables within a given service, or a given table
  def describe(service = nil, table = nil)
    path = 'services'
    if service and table
      path += "/#{service}/#{table}"
    elsif service and !table
      path += "/#{service}"
    elsif !service and table
      raise "Service must be specified if table is specified"
    end

    request path
  end

  # Paginated printing of an SQL query
  def print_query(sql)
    IRB::Pager.pager {
      query(sql) do |l|
        puts l
      end
    }
  end

  # Issue a SQL query, yielding each row
  def query(sql)
    path = 'query'
    io = request path, :post, {}, {query: sql}, stream: true
    io.each do |l|
      yield l
    end
  end

  # Insert a new row into this service table. The row should be a hash of {column: value}
  def insert(service, table, row)
    path = "services/#{service}/#{table}"
    request path, :post, {}, row
  end

  # Materialize a SQL query as a view. This creates or updates a view.
  def materialize_view(name, sql)
    unless @end_user
      raise "Cannot use materialized view within a session initiated without an enduser"
    end
    path = "view/#{name}"
    data = {'query' => sql}
    request path, :put, {}, data
  end

  # Delete a materialized view of SQL query
  def drop_view(name)
    unless @end_user
      raise "Cannot use materialized view within a session initiated without an enduser"
    end
    path = "view/#{name}"
    request path, :delete
  end

  # Boolean check if a materialized view is ready for querying.
  # @note The user is expected to check view_ready? before querying a view with query()
  def view_ready?(name)
    status = view_status(name)

    case status['viewStatus']
    when 'ready' then true
    when 'pending' then false
    else
      raise "Unknown view status: #{response['viewStatus']}"
    end
  end

  # Datetime that this view was materialized at.
  # nil if the materialization is currently pending.
  def view_materialized_at(name)
    status = view_status(name)
    Date.parse(status['materializedAt']) rescue nil
  end

  # emulate default Object#inspect method but only display the object_id, not the properties
  # to make things cleaner and more similar to Python client
  def inspect
    "#<Empire:#{(object_id << 1).to_s(16)}>"
  end

  private

  def view_status(name)
    unless @end_user
      raise "Cannot use materialized view within a session initiated without an enduser"
    end
    path = "view/#{name}/status"
    request path, :get
  end

  def request(path, method = :get, headers = {}, data = {}, opts = {})
    create_session unless @sessionkey
    headers_with_session = headers.merge({'Authorization' => "Empire sessionkey=\"#{@sessionkey}\""})
    do_request path, method, headers_with_session, data, opts
  end

  def create_session
    headers = {'Authorization' => "Empire appkey=\"#{@app_key}\""}
    session_url = "session/create"
    if @end_user
      session_url = session_url + "?enduser=#{@end_user}"
    end
    data = do_request session_url, :post, headers
    @sessionkey = data['sessionkey']
  end

  def do_request(path, method = :get, headers = {}, data = {}, opts = {})
    url = @base_url + path
    headers.merge!({'Content-Type' => 'application/json', 'Accept' => '*/*'})
    if opts[:stream]
      # return an IO object representing the streamed content
      conn = @http_client.request_async method, url, nil, data.to_json, headers
      conn.pop.content
    else
      # return the response body
      response = @http_client.request method, url, body: data.to_json, header: headers
      if response.status == HTTP::Status::INTERNAL
        raise "Internal Server Error"
      end
      JSON.parse(response.body)
    end
  end
end
